snippet im
	import "${1:package}"
snippet ims
	import (
		"${1:package}"
	)
snippet co
	const ${1:name} = ${2:value}
snippet cos
	const (
		${1:name} = ${2:value}
	)
snippet tyi
	type ${1:name} interface {
		$0
	}
snippet tys
	type ${1:name} struct {
		$0
	}
snippet pkgm
	package main
	
	func main() {
		$0
	}
snippet func
	func $1($2) $3 {
		$0
	}
snippet var
	var ${1:name} ${2:type}
snippet switch
	switch ${1:expression} {
	case ${2:condition}:
		$0
	}
snippet sel
	select {
	case ${1:condition}:
		$0
	}
snippet cs
	case ${1:condition}:$0
snippet for
	for ${1:i} := 0; $1 < ${2:count}; $1${3:++} {
		$0
	}
snippet forr
	for ${1:_, }${2:var} := range ${3:var} {
		$0
	}
snippet ch
	chan ${1:type}
snippet map
	map[${1:type}]${2:type}
snippet in
	interface{}
snippet if
	if ${1:condition} {
		$0
	}
snippet else
	else {
		$0
	}
snippet if else
	if ${1:condition} {
		$2
	} else {
		$0
	}
snippet iferr
	if err != nil {
		${1:return ${2:nil, }${3:err}}
	}
snippet fp
	fmt.Println("$1")
snippet ff
	fmt.Printf("$1", ${2:var})
snippet lp
	log.Println("$1")
snippet lf
	log.Printf("$1", ${2:var})
snippet lv
	log.Printf("${1:var}: %#+v\\\\n\", ${1:var})
snippet tl
	t.Log("$1")
snippet tlf
	t.Logf("$1", ${2:var})
snippet tlv
	t.Logf("${1:var}: %#+v\\\\n\", ${1:var})
snippet make
	make(${1:type}, ${2:0})
snippet new
	new(${1:type})
snippet panic
	panic("$0")
snippet wr
	${1:w} http.ResponseWriter, ${2:r} *http.Request
snippet hf
	${1:http}.HandleFunc("${2:}", ${3:handler})
snippet http handler
	func $1(${2:w} http.ResponseWriter, ${3:r} *http.Request) {
		$0
	}
snippet http.Redirect
	http.Redirect(${1:w}, ${2:r}, "${3:}", ${4:http.StatusFound})
snippet http.Error
	http.Error(${1:w}, ${2:err}.Error(), ${3:http.StatusInternalServerError})
snippet http.ListenAndServe
	http.ListenAndServe("${1::8080}", ${2:nil})
snippet http.Serve
	http.Serve("${1::8080}", ${2:nil})
snippet go
	go func($1) {
		$0
	}($2)
snippet gf
	go ${1:func}($0)
snippet defer
	defer ${1:func}($0)
snippet test func
	func Test$1(t *testing.T) {
		$0
	}
snippet benchmark func
	func Benchmark$1(b *testing.B) {
		for ${2:i} := 0; ${2:i} < b.N; ${2:i}++ {
			$0
		}
	}
snippet example func
	func Example$1() {
		$2
		//Output:
		$3
	}
snippet tdt
	func Test$1(t *testing.T) {
		testCases := []struct {
			desc	string
			$2
		}{
		{
			desc: \"$3\",
				$4
			},
		}
		for _, tC := range testCases {
			t.Run(tC.desc, func(t *testing.T) {
				$0
			})
		}
	}
snippet func init
	func init() {
		$1
	}
snippet func main
	func main() {
		$1
	}
snippet meth
	func (${1:receiver} ${2:type}) ${3:method}($4) $5 {
		$0
	}
snippet helloweb
	package main
	
	import (
		"fmt"
		"net/http"
		"time"
		)
		func greet(w http.ResponseWriter, r *http.Request) {
			fmt.Fprintf(w, \"Hello World! %s\", time.Now())
		}
		func main() {
			http.HandleFunc(\"/\", greet)
				http.ListenAndServe(\":8080\", nil)
		}
snippet sort
	type ${1:SortBy} []${2:Type}
	
	func (a $1) Len() int           { return len(a) }
	func (a $1) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
	func (a $1) Less(i, j int) bool { ${3:return a[i] < a[j]} }
snippet checkerr
	if err != nil {
		${1:log}.Fatal(err)
	}

snippet returnerr
	if err != nil {
		return ${1:result}, err
	}

snippet dbconnect
	db, err := sql.Open("${1:mysql}", "${2:username}:${3:password}@tcp(${4:localhost}:3306)/${5:dbname}")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

snippet queryrows
	rows, err := db.Query("${1:SELECT * FROM ${2:table}}")
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()

	for rows.Next() {
		// scan row data here
	}

snippet wg
	var wg sync.WaitGroup
	wg.Add(${1:n})
	for i := 0; i < ${1:n}; i++ {
		go func(i int) {
			defer wg.Done()
			$0
		}(i)
	}
	wg.Wait()

snippet timer
	timer := time.NewTimer(${1:time.Second})
	defer timer.Stop()

	select {
	case <-timer.C:
		$0
	}

snippet ticker
	ticker := time.NewTicker(${1:time.Second})
	defer ticker.Stop()

	for range ticker.C {
		$0
	}

snippet jsonmarshal
	data, err := json.Marshal(${1:obj})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(data))

snippet jsonunmarshal
	var ${1:obj} ${2:Type}
	err := json.Unmarshal(${3:jsonData}, &${1:obj})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%+v\\n", ${1:obj})

snippet filewrite
	file, err := os.Create("${1:filename}")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	_, err = file.WriteString("${2:content}")
	if err != nil {
		log.Fatal(err)
	}

snippet fileread
	file, err := os.Open("${1:filename}")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}

snippet httpget
	resp, err := http.Get("${1:url}")
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(body))

snippet httppost
	resp, err := http.Post("${1:url}", "application/json", bytes.NewBuffer(${2:data}))
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(body))

snippet muxrouter
	r := mux.NewRouter()
	r.HandleFunc("${1:/path}", ${2:handler}).Methods("${3:GET}")

	http.Handle("/", r)
	log.Fatal(http.ListenAndServe(":8080", nil))

snippet jsonresponse
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(${1:response})

snippet middleware
	func loggingMiddleware(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			log.Printf("%s %s", r.Method, r.URL.Path)
			next.ServeHTTP(w, r)
		})
	}

	func main() {
		r := mux.NewRouter()
		r.Use(loggingMiddleware)
		http.Handle("/", r)
		log.Fatal(http.ListenAndServe(":8080", nil))
	}

snippet mocktest
	type mock${1:Service} struct{}

	func (m *mock$1) ${2:Method}(arg ${3:Type}) (${4:ResultType}, error) {
		return ${5:result}, nil
	}

	func Test${1}Method(t *testing.T) {
		mock := &mock${1}{}
		${6:expected}, err := mock.${2:Method}(${7:arg})

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		if ${6:expected} != ${5:result} {
			t.Fatalf("expected %v, got %v", ${5:result}, ${6:expected})
		}
	}
	snippet goroutine
	go func() {
		$0
	}()
	snippet gofunc
	go ${1:func}()
	### Goroutines

snippet goroutine
	go func() {
		$0
	}()

snippet gofunc
	go ${1:func}()

### Channels

snippet makechan
	ch := make(chan ${1:type}, ${2:bufferSize})

snippet sendchan
	${1:ch} <- ${2:value}

snippet receivechan
	${1:val} := <-${2:ch}

snippet closechan
	close(${1:ch})

### Select Statement (for Channels)

snippet select
	select {
	case ${1:val} := <-${2:ch}:
		$0
	default:
		$0
	}

snippet selecttimeout
	select {
	case ${1:val} := <-${2:ch}:
		$0
	case <-time.After(${3:time.Second}):
		$0
	}

### WaitGroup

snippet wginit
	var wg sync.WaitGroup
	wg.Add(${1:n})

snippet wgdone
	defer wg.Done()

snippet wgwait
	wg.Wait()

snippet wgexample
	var wg sync.WaitGroup

	for i := 0; i < ${1:n}; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			$0
		}(i)
	}

	wg.Wait()

### Mutex

snippet mutex
	var mu sync.Mutex

snippet mu_lock
	mu.Lock()
	defer mu.Unlock()

snippet rwmutex
	var rw sync.RWMutex

snippet rw_lock
	rw.Lock()
	defer rw.Unlock()

snippet rw_rlock
	rw.RLock()
	defer rw.RUnlock()

### Worker Pool Pattern

snippet workerpool
	const numWorkers = ${1:5}

	func worker(id int, jobs <-chan ${2:Job}, results chan<- ${3:Result}) {
		for j := range jobs {
			$0
		}
	}

	func main() {
		jobs := make(chan ${2:Job}, ${4:numJobs})
		results := make(chan ${3:Result}, ${4:numJobs})

		for w := 1; w <= numWorkers; w++ {
			go worker(w, jobs, results)
		}

		for j := 1; j <= ${4:numJobs}; j++ {
			jobs <- ${2:job}
		}
		close(jobs)

		for a := 1; a <= ${4:numJobs}; a++ {
			<-results
		}
	}

### Once (for Single Execution)

snippet once
	var once sync.Once

	once.Do(func() {
		$0
	})

### Context (for Timeouts or Cancellation)

snippet context
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

snippet contexttimeout
	ctx, cancel := context.WithTimeout(context.Background(), ${1:time.Second})
	defer cancel()

snippet contextdone
	select {
	case <-ctx.Done():
		$0
	}

### Rate Limiting

snippet ratelimit
	limiter := time.Tick(${1:time.Second})

	for ${2:task} := range ${3:tasks} {
		<-limiter
		$0
	}

### Fan-In Pattern

snippet fanin
	func fanIn(input1, input2 <-chan ${1:Type}) <-chan ${1:Type} {
		c := make(chan ${1:Type})
		go func() { for { c <- <-input1 } }()
		go func() { for { c <- <-input2 } }()
		return c
	}

### Fan-Out Pattern

snippet fanout
	func fanOut(input <-chan ${1:Type}, outputs []chan ${1:Type}) {
		for val := range input {
			for _, out := range outputs {
				out <- val
			}
		}
	}

### Bounded Buffer

snippet boundedbuffer
	type BoundedBuffer struct {
		buf chan ${1:Type}
	}

	func NewBoundedBuffer(size int) *BoundedBuffer {
		return &BoundedBuffer{buf: make(chan ${1:Type}, size)}
	}

	func (b *BoundedBuffer) Put(item ${1:Type}) {
		b.buf <- item
	}

	func (b *BoundedBuffer) Get() ${1:Type} {
		return <-b.buf
	}